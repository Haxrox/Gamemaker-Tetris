<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Making Variables
// Making the main matrix
for (r = 0; r &lt; 26; r = r + 1;) {
    for (c = 0; c &lt; 10; c = c + 1) {
        mainMatrix[r, c] = 0
    }
}
game = true
positionX = 3
positionY = 0
ghostY = 25
currentRotation = 0
holdMino = 0
hold = false
clearStats = ''
combo = ''
dropValue = 0
minoBag = createBag(PIECES)
currentMino = getPiece()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if keyboard_check(vk_right) and checkForOverlapping(mainMatrix, currentMino, positionX + 1, positionY) {
    positionX = positionX + 1
    alarm[0] = 1
    audio_play_sound(SFX_Movement, 1, false)
}
else if keyboard_check(vk_left) and checkForOverlapping(mainMatrix, currentMino, positionX - 1, positionY) {
    positionX = positionX - 1
    alarm[0] = 1
    audio_play_sound(SFX_Movement, 1, false)
}
    
if keyboard_check_released(vk_left) or keyboard_check_released(vk_right){}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Moving pieces
if game {
    if keyboard_check_pressed(vk_up) {
        currentMino = rotatePiece(currentMino, 90)
        audio_play_sound(SFX_Movement, 1, false)
    }
    
    if keyboard_check_pressed(ord("Z")) {
        currentMino = rotatePiece(currentMino, -90)
        audio_play_sound(SFX_Movement, 1, false)
    }
    if keyboard_check_pressed(vk_right) and checkForOverlapping(mainMatrix, currentMino, positionX + 1, positionY) {
        positionX = positionX + 1
        alarm[0] = 3.51
        audio_play_sound(SFX_Movement, 1, false)
    }
    
    if keyboard_check_pressed(vk_left) and checkForOverlapping(mainMatrix, currentMino, positionX - 1, positionY) {
        positionX = positionX - 1
        alarm[0] = 3.51
        audio_play_sound(SFX_Movement, 1, false)
    }
    
    if keyboard_check(vk_down) and checkForOverlapping(mainMatrix, currentMino, positionX, positionY + 1) {
        positionY = positionY + 1
        POINTS ++
        audio_play_sound(SFX_Drop, 0, false)
    }   
    
    if keyboard_check_pressed(vk_shift){
        if !hold {
            if !is_array(holdMino) {while currentRotation != 0 {currentMino = rotatePiece(currentMino, -sign(currentRotation))}; holdMino = currentMino; currentMino = getPiece()}   
            else {var bufferMino = holdMino; while currentRotation != 0 {currentMino = rotatePiece(currentMino, -sign(currentRotation));}  holdMino = currentMino; currentMino = bufferMino}
            ghostY = 0
            currentRotation = 0
            positionX = 3
            positionY = 0
            hold = true
            alarm[0] = 1
        }
    }
    
    if keyboard_check_pressed(vk_space){
        mainMatrix = dropPiece(mainMatrix, currentMino, positionX, positionY)
        alarm[0] = 1
    }
    //Insta-Drop
    dropValue ++
    if dropValue &gt;= 30 {
        if checkForOverlapping(mainMatrix, currentMino, positionX, positionY + 1) {positionY ++; dropValue = 0}
        else if dropValue &gt;= 60 {mainMatrix = dropPiece(mainMatrix, currentMino, positionX, positionY); dropValue = 0}
    }
}
else {instance_destroy()}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw everything
// Draws the main matrix
for (mainMatrixRow = 0; mainMatrixRow &lt; 26; mainMatrixRow ++;) {
    for (mainMatrixColumn = 0; mainMatrixColumn &lt; 10; mainMatrixColumn ++) {
        draw_set_colour(c_white)
        draw_set_alpha(0.7)
        draw_rectangle
        (
            160 + (mainMatrixColumn * BRICK_SIZE), 
            6 + mainMatrixRow * BRICK_SIZE, 
            160 + (mainMatrixColumn * BRICK_SIZE + BRICK_SIZE), 
            6 + mainMatrixRow * BRICK_SIZE + BRICK_SIZE, 
            true
        )
        draw_set_alpha(1)
        if mainMatrix[mainMatrixRow, mainMatrixColumn] != 0 {
            draw_rectangle_colour
            (
                160 + (mainMatrixColumn * BRICK_SIZE), 
                6 + mainMatrixRow * BRICK_SIZE, 
                160 + (mainMatrixColumn * BRICK_SIZE + BRICK_SIZE), 
                6 + mainMatrixRow * BRICK_SIZE + BRICK_SIZE, 
                COLORS[mainMatrix[mainMatrixRow, mainMatrixColumn]], 
                COLORS[mainMatrix[mainMatrixRow, mainMatrixColumn]], 
                COLORS[mainMatrix[mainMatrixRow, mainMatrixColumn]], 
                COLORS[mainMatrix[mainMatrixRow, mainMatrixColumn]], 
                false
            )
        }   
    }
}
// Draws the currentMino    
for(currentMinoRow = (array_height_2d(currentMino) - 1); currentMinoRow &gt; -1; currentMinoRow --) {
    for(currentMinoColumn = (array_length_2d(currentMino, currentMinoRow) - 1); currentMinoColumn &gt; -1; currentMinoColumn --) {
        if currentMino[currentMinoRow, currentMinoColumn] != 0 {
            draw_rectangle_colour(
                160 + (currentMinoColumn * BRICK_SIZE + positionX * BRICK_SIZE), 
                6 + currentMinoRow * BRICK_SIZE + positionY * BRICK_SIZE, 
                160 + (currentMinoColumn * BRICK_SIZE + positionX * BRICK_SIZE + BRICK_SIZE), 
                6 + currentMinoRow * BRICK_SIZE + positionY * BRICK_SIZE + BRICK_SIZE, 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                false
            )
            draw_set_alpha(0.5)
// Drawing the ghost
            ghostY = drawGhost(ghostY)
            if positionY &gt;= ghostY {ghostY = positionY}
            draw_rectangle_colour
            (
                160 + (currentMinoColumn * BRICK_SIZE + positionX * BRICK_SIZE), 
                6 + currentMinoRow * BRICK_SIZE + ghostY * BRICK_SIZE, 
                160 + (currentMinoColumn * BRICK_SIZE + positionX * BRICK_SIZE + BRICK_SIZE), 
                6 + currentMinoRow * BRICK_SIZE + ghostY * BRICK_SIZE + BRICK_SIZE, 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                COLORS[currentMino[currentMinoRow, currentMinoColumn]], 
                false
            )
            draw_set_alpha(1)
        }
    }
}
//Draws the queue pieces
if (ds_list_size(minoBag) &gt; 0) {
    for (queuePieceNum = 0; queuePieceNum &lt; 5; queuePieceNum ++) {
        queuePiece = ds_list_find_value(minoBag, queuePieceNum)
        for (queuePieceRow = (array_height_2d(queuePiece) - 1); queuePieceRow &gt; -1; queuePieceRow --){
            for (queuePieceColumn = (array_length_2d(queuePiece, queuePieceRow) - 1); queuePieceColumn &gt; -1; queuePieceColumn -- ){
                if (queuePiece[queuePieceRow, queuePieceColumn] != 0) {
                    draw_rectangle_colour(
                         496 + (queuePieceColumn * BRICK_SIZE),
                         76 + (queuePieceNum * 96 + (queuePieceRow * BRICK_SIZE)),
                         496 + (queuePieceColumn * BRICK_SIZE + BRICK_SIZE),
                         76 + (queuePieceNum * 96 + (queuePieceRow * BRICK_SIZE + BRICK_SIZE)),
                         COLORS[queuePiece[queuePieceRow, queuePieceColumn]], 
                         COLORS[queuePiece[queuePieceRow, queuePieceColumn]], 
                         COLORS[queuePiece[queuePieceRow, queuePieceColumn]], 
                         COLORS[queuePiece[queuePieceRow, queuePieceColumn]], 
                         false   
                    )
                }
            }    
        }
    }
}
//Draws the holdMino
if is_array(holdMino) {
    for (holdMinoRow = (array_height_2d(holdMino) - 1); holdMinoRow &gt; -1; holdMinoRow --){
        for (holdMinoColumn = (array_length_2d(holdMino, holdMinoRow) - 1); holdMinoColumn &gt; -1; holdMinoColumn --){
            if (holdMino[holdMinoRow, holdMinoColumn] != 0) {
                draw_rectangle_colour(
                    16 + (holdMinoColumn * BRICK_SIZE), 
                    80 + (holdMinoRow * BRICK_SIZE), 
                    16 + (holdMinoColumn * BRICK_SIZE + BRICK_SIZE), 
                    80 + (holdMinoRow * BRICK_SIZE + BRICK_SIZE), 
                    COLORS[holdMino[holdMinoRow, holdMinoColumn]], 
                    COLORS[holdMino[holdMinoRow, holdMinoColumn]], 
                    COLORS[holdMino[holdMinoRow, holdMinoColumn]], 
                    COLORS[holdMino[holdMinoRow, holdMinoColumn]], 
                    false
                )
            }
        }
    }
}
//Draws the clearing status/Combo
draw_set_font(Impact)
draw_text(490, 30, "Points: " + string(POINTS))
draw_text(490, 24 * BRICK_SIZE, clearStats)
draw_text(490, 24 * BRICK_SIZE + BRICK_SIZE, string(combo))
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
